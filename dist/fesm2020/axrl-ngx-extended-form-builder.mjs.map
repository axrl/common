{"version":3,"file":"axrl-ngx-extended-form-builder.mjs","sources":["../../projects/ngx-extended-form-builder/src/lib/ngx-extended-form-builder.ts","../../projects/ngx-extended-form-builder/src/public-api.ts","../../projects/ngx-extended-form-builder/src/axrl-ngx-extended-form-builder.ts"],"sourcesContent":["import { FormGroup, FormArray, FormControl } from \"@angular/forms\";\r\nimport type { ValidatorFn, ValidationErrors, AsyncValidatorFn, AbstractControl, FormControlOptions } from \"@angular/forms\";\r\nimport { Observable } from \"rxjs\";\r\n\r\n/**\r\n * Вспомогательная утилита типа.\r\n * На вход принимает некий тип T, возвращает список только строковых ключей этого типа, при этом значения этих ключей не являются Observable.\r\n */\r\nexport type StringKeys<T> = {\r\n  [K in keyof T]: T[K] extends Observable<unknown> ?\r\n  never :\r\n  K extends string ?\r\n  K : never;\r\n}[keyof T];\r\n\r\n/**\r\n * Вспомогательный alias-тип ключей в объекте Map, содержащем конфигурацию валидаторов контролов.\r\n */\r\nexport type ControlsNames<T> = T extends Observable<unknown> ?\r\n  never :\r\n  T extends Array<infer U> ?\r\n  'main' | 'mainItems' | `mainItems.${PropertyesKeys<U>}` :\r\n  'main' | PropertyesKeys<T>;\r\n/**\r\n * Вспомогательная утилита типа.\r\n * На вход принимает некий тип T, возвращает только строковые ключи этого типа.\r\n */\r\nexport type PropertyesKeys<T> = T extends undefined | null | number | boolean | symbol | Observable<unknown> ?\r\n  never :\r\n  T extends Readonly<string> ?\r\n  T :\r\n  T extends string ?\r\n  T :\r\n  T extends Array<infer U> ?\r\n  PropertyesKeys<U> :\r\n  {\r\n    [K in keyof T]-?: K extends string ?\r\n    T[K] extends (string | number | boolean | symbol | undefined | null) ?\r\n    K :\r\n    T[K] extends Observable<unknown> ?\r\n    never :\r\n    T[K] extends Array<infer U> ?\r\n    `${K}Items.${PropertyesKeys<U>}` | `${K}Items` | K :\r\n    `${K}.${PropertyesKeys<T[K]>}` | K : never\r\n  }[keyof T];\r\n/**\r\n * Упрощенная запись для типа объекта FormGroup, образованного из типа T.\r\n */\r\nexport type FormGroupType<T extends object> = FormGroup<{ [K in keyof T]: ScanFormType<T[K]>; }>;\r\n\r\n/**\r\n * Универсальный тип-утилита.\r\n * Для любого типа Т выводит правильный тип создаваемой формы, включая любой уровень вложенности.\r\n * ВАЖНО!\r\n * Чтобы избежать ошибки переполнения стэка вызовов в рекурсивном процессе создания формы, для любых\r\n * Observable-значений ( в т.ч., к примеру, Subject  * и EventEmitter) соответствующий элемент формы не создается.\r\n * ScanFormType это также учитывает.\r\n */\r\nexport type ScanFormType<T> =\r\n  T extends (null | undefined) ?\r\n  never :\r\n  T extends Readonly<string> ?\r\n  FormControl<string | null> :\r\n  T extends (string | symbol) ?\r\n  FormControl<T | null> :\r\n  T extends boolean ?\r\n  FormControl<boolean | null> :\r\n  T extends number ?\r\n  FormControl<number | null> :\r\n  T extends AbstractControl ?\r\n  T :\r\n  T extends Array<infer U> ?\r\n  FormArray<ScanFormType<U>> :\r\n  T extends object ?\r\n  FormGroupType<T> :\r\n  never;\r\n\r\ntype MakeControlOptions = Omit<FormControlOptions, 'validators' | 'asyncValidators'> & {\r\n  disabled?: boolean;\r\n  validators?: ValidatorFn[];\r\n  asyncValidators?: AsyncValidatorFn[];\r\n};\r\n\r\nfunction getValidatorsOrNull<T>(\r\n  key: ControlsNames<T>,\r\n  options?: Map<ControlsNames<T>, MakeControlOptions>,\r\n  addLift: boolean = false\r\n): MakeControlOptions | null | undefined {\r\n  const result = options && options.has(key) ? options.get(key) : null;\r\n  if (addLift) {\r\n    if (result && result.validators) {\r\n      result.validators.push(<ValidatorFn>liftErrors);\r\n      return result;\r\n    } else {\r\n      if (result) {\r\n        result.validators = [liftErrors];\r\n        return result;\r\n      } else {\r\n        return {\r\n          validators: [liftErrors]\r\n        };\r\n      };\r\n    }\r\n  } else {\r\n    return result;\r\n  };\r\n}\r\n\r\nfunction makeNewMainMap<I, O>(\r\n  key: ControlsNames<I>,\r\n  oldMap?: Map<ControlsNames<I>, MakeControlOptions>,\r\n): Map<ControlsNames<O>, MakeControlOptions> | undefined {\r\n  if (!oldMap || key === 'main') {\r\n    return <Map<ControlsNames<O>, MakeControlOptions> | undefined>oldMap;\r\n  } else {\r\n    if (!oldMap.has(key) && !oldMap.has(<ControlsNames<I>>`${key}Items`)) {\r\n      return new Map<ControlsNames<O>, MakeControlOptions>(\r\n        Array.from(\r\n          oldMap.entries()\r\n        ).filter(\r\n          item => item[0] !== 'main' && item[0] !== 'mainItems'\r\n        ).map(\r\n          ([entryKey, entryValue]) => [<ControlsNames<O>>(entryKey.startsWith(`${key}.`) ? entryKey.replace(`${key}.`, '') : entryKey), entryValue]\r\n        )\r\n      );\r\n    } else {\r\n      const filterPredicate = oldMap.has(<ControlsNames<I>>'main') ?\r\n        oldMap.has(<ControlsNames<I>>'mainItems') ?\r\n          (item: [ControlsNames<I>, MakeControlOptions]) => {\r\n            const pre = item[0] !== (key + 'Items');\r\n            return item[0] !== key && pre && item[0] !== 'main' && item[0] !== 'mainItems';\r\n          } :\r\n          (item: [ControlsNames<I>, MakeControlOptions]) => {\r\n            const pre = item[0] !== (key + 'Items');\r\n            return item[0] !== key && key[0] !== (key + 'Items') && item[0] !== 'main';\r\n          } :\r\n        oldMap.has(<ControlsNames<I>>'mainItems') ?\r\n          (item: [ControlsNames<I>, MakeControlOptions]) => {\r\n            const pre = item[0] !== (key + 'Items');\r\n            return item[0] !== key && pre && item[0] !== 'mainItems';\r\n          } :\r\n          (item: [ControlsNames<I>, MakeControlOptions]) => {\r\n            const pre = item[0] !== (key + 'Items');\r\n            return item[0] !== key && pre;\r\n          };\r\n      const newMainValidatorsArray: [ControlsNames<O>, MakeControlOptions][] = oldMap.has(key) ?\r\n        oldMap.has(<ControlsNames<I>>`${key}Items`) ?\r\n          [\r\n            [<ControlsNames<O>>'main', oldMap.get(key)!],\r\n            [<ControlsNames<O>>'mainItems', oldMap.get(<ControlsNames<I>>`${key}Items`)!]\r\n          ] :\r\n          [\r\n            [<ControlsNames<O>>'main', oldMap.get(key)!],\r\n          ] :\r\n        oldMap.has(<ControlsNames<I>>`${key}Items`) ?\r\n          [\r\n            [<ControlsNames<O>>'mainItems', oldMap.get(<ControlsNames<I>>`${key}Items`)!]\r\n          ] :\r\n          [];\r\n      const filtered = Array.from(\r\n        oldMap.entries()\r\n      ).filter(filterPredicate);\r\n      const result = new Map<ControlsNames<O>, MakeControlOptions>([\r\n        ...newMainValidatorsArray,\r\n        ...filtered.map<[ControlsNames<O>, MakeControlOptions]>(\r\n          ([entryKey, entryValue]) => [<ControlsNames<O>>(\r\n            entryKey.startsWith(`${key}.`) ?\r\n              entryKey.replace(`${key}.`, '') :\r\n              entryKey.startsWith(`${key}Items.`) ?\r\n                entryKey.replace(`${key}Items.`, '') :\r\n                entryKey\r\n          ), entryValue]\r\n        )\r\n      ]);\r\n      return result;\r\n    };\r\n  };\r\n}\r\n\r\n/**\r\n@function makeForm<T>\r\n  Фабричная функция для создания Angular Reactive Form.\r\nВ отличие от стандартного FormBuilder - а в пакете @angular/forms, при создании формы из сложных объектов,\r\nсохраняется вложенность контролов - каждый вложенный объект превращается во вложенную FormGroup,\r\n  обычные свойства объектов становятся FormControl - ами, а массивы - FormArray - ми.\r\nПри этом создаваемая форма имеет более строгую типизацию.\r\n\r\n  ВАЖНО!\r\n   Чтобы избежать ошибки переполнения стэка вызовов в рекурсивном процессе создания формы, для любых;\r\nObservable - значений(в т.ч., к примеру, Subject * и EventEmitter) соответствующий элемент формы не создается.\r\n * @param source  источник данных типа T для создания формы.\r\n * @param keysValidator объект Map с конфигурацией синхронных валидаторов контролов формы.\r\n * В качестве ключей могут быть указаны следующие значения:\r\n *  PropertyesKeys<T> - строковые ключи в типе T, включая строковые ключи всех вложенных типов, разделенные \".\" - точкой.\r\n    Например имеется такой тип:\r\n    ```ts\r\n                    interface User {\r\n                      firstname: string;\r\n                      lastname: string;\r\n                      phone:  {\r\n                        code: string;\r\n                        number: string;\r\n                        }\r\n                      };\r\n    ```\r\n    Для формы, которая будет создана из объекта User в конфигурации валидаторов названия контролов можно будет указать так:\r\n    `lastname` или`phone`, или`phone.code`.\r\n\r\n   'main' - специальное значение, являющееся признаком того, что массив валидаторов необходимо\r\n    назначить самому объекту формы, а не вложеным контролам.\r\n\r\n   'mainItems' - используется только если source является массивом. Специальное значение, являющееся признаком того,\r\n  что массив валидаторов необходимо назначить для всех элементов массива FormArray.\r\n * @param asyncKeysValidator объект Map, аналогичный keysValidator, но для асинхронных валидаторов\r\n * @returns объект типизированной формы - FormGroup, FormArray или FormControl в зависимости от типа значения source.\r\n */\r\nexport function makeForm<T extends unknown>(\r\n  source: T,\r\n  options?: Map<ControlsNames<T>, MakeControlOptions>,\r\n): ScanFormType<T> {\r\n  const form = !!source && (typeof source === 'object' || typeof source === 'function') ?\r\n    source instanceof Array<unknown> ?\r\n      makeArray(source, options) :\r\n      makeGroup(<object>source, 'main', options) :\r\n    makeControl(<undefined | null | number | boolean | symbol | string>source, options);\r\n  return <ScanFormType<T>>form;\r\n};\r\n\r\nfunction liftErrors(control: AbstractControl): ValidationErrors | null {\r\n  if (control instanceof FormControl) {\r\n    return null;\r\n  } else {\r\n    const allControls = control instanceof FormGroup ?\r\n      Object.values(control.controls) :\r\n      control instanceof FormArray ?\r\n        control.controls :\r\n        [];\r\n    const invalidControls = allControls.filter(control => control.status === 'INVALID');\r\n    return invalidControls.length === 0 ? null : invalidControls.reduce(\r\n      (accumulator, current) => {\r\n        if (current.errors) {\r\n          addValidationErrors(current.errors, accumulator);\r\n        };\r\n        return accumulator;\r\n      }, <ValidationErrors>{}\r\n    );\r\n  }\r\n}\r\n\r\nexport function liftValidationErrors(control: AbstractControl): ValidationErrors | null {\r\n  const allControls = control instanceof FormGroup ?\r\n    Object.values(control.controls) :\r\n    control instanceof FormArray ?\r\n      control.controls :\r\n      [];\r\n  const invalidControls = allControls.filter(control => control.status === 'INVALID');\r\n  const errors: ValidationErrors = invalidControls.length === 0 ? {} : invalidControls.reduce(\r\n    (accumulator, current) => {\r\n      if (current.errors) {\r\n        addValidationErrors(current.errors, accumulator);\r\n      };\r\n      const innerErrors = liftValidationErrors(current);\r\n      if (innerErrors) {\r\n        addValidationErrors(innerErrors, accumulator);\r\n      };\r\n      return accumulator;\r\n    }, <ValidationErrors>{}\r\n  );\r\n  return Object.values(errors).length === 0 ? null : errors;\r\n};\r\n\r\nfunction addValidationErrors(additionErrors: ValidationErrors, currentErrors: ValidationErrors) {\r\n  Object.entries(additionErrors).forEach(\r\n    entry => currentErrors[entry[0]] = entry[1]\r\n  );\r\n}\r\n\r\nfunction makeControl<T extends undefined | null | number | boolean | symbol | string>(\r\n  source: T | FormControl<T | null>,\r\n  options?: Map<ControlsNames<T>, MakeControlOptions>\r\n): FormControl<T | null> {\r\n  const controlOptions = getValidatorsOrNull(<ControlsNames<T>>'main', options, false);\r\n  const result = source instanceof FormControl ?\r\n    source :\r\n    new FormControl<T | null>(\r\n      !!source && typeof source == 'string' && (source.includes('0001-01-01') || source.includes('1970-01-01')) ? null : source\r\n      ,\r\n      {\r\n        validators: controlOptions?.validators,\r\n        asyncValidators: controlOptions?.asyncValidators,\r\n        updateOn: controlOptions?.updateOn,\r\n        nonNullable: controlOptions?.nonNullable\r\n      },\r\n    );\r\n  if (controlOptions?.disabled) {\r\n    result.disable();\r\n  };\r\n  return result;\r\n}\r\n\r\nfunction makeGroup<T extends object = object>(\r\n  source: T | FormGroupType<T>,\r\n  internalKey: ControlsNames<T>,\r\n  options?: Map<ControlsNames<T>, MakeControlOptions>\r\n): FormGroupType<T> {\r\n  const controlOptions = getValidatorsOrNull(internalKey, options, false);\r\n  const result = source instanceof FormGroup<{ [K in StringKeys<T>]: ScanFormType<T[K]>; }> ?\r\n    source :\r\n    (<[StringKeys<T>, T[StringKeys<T>]][]>Object.entries(source)).reduce(\r\n      (accumulator: FormGroup, entry: [StringKeys<T>, T[StringKeys<T>]]) => {\r\n        const key = entry[0];\r\n        const value = entry[1];\r\n        if (!(value instanceof Observable)) {\r\n          accumulator.addControl(\r\n            key,\r\n            !!value && (\r\n              value instanceof FormGroup || value instanceof FormArray || value instanceof FormControl\r\n            ) ?\r\n              <ScanFormType<T[StringKeys<T>]>>value :\r\n              makeForm<T[StringKeys<T>]>(\r\n                value,\r\n                makeNewMainMap<T, T[StringKeys<T>]>(<ControlsNames<T>>key, options),\r\n              )\r\n          );\r\n        };\r\n        return <FormGroupType<T>>accumulator;\r\n      }, new FormGroup<{ [K in StringKeys<T>]: ScanFormType<T[K]>; }>(<{ [K in StringKeys<T>]: ScanFormType<T[K]>; }>{},\r\n        {\r\n          validators: controlOptions?.validators,\r\n          asyncValidators: controlOptions?.asyncValidators,\r\n          updateOn: controlOptions?.updateOn,\r\n        },\r\n      )\r\n    );\r\n  if (controlOptions?.disabled) {\r\n    result.disable();\r\n  };\r\n  return result;\r\n}\r\n\r\nfunction makeArray<T extends Array<unknown>, E = T extends Array<infer U> ? U : never>(\r\n  source: E[] | FormArray<ScanFormType<E>>,\r\n  options?: Map<ControlsNames<T>, MakeControlOptions>\r\n): FormArray<ScanFormType<E>> {\r\n  const controlOptions = getValidatorsOrNull(<ControlsNames<T>>'main', options, false);\r\n  const result = source instanceof FormArray ?\r\n    source :\r\n    new FormArray(\r\n      source.map(\r\n        (item: E) => {\r\n          const itemForm = makeForm(\r\n            item,\r\n            makeNewMainMap<T, E>(<ControlsNames<T>>'mainItems', options),\r\n          );\r\n          return itemForm;\r\n        }),\r\n      {\r\n        validators: controlOptions?.validators,\r\n        asyncValidators: controlOptions?.asyncValidators,\r\n        updateOn: controlOptions?.updateOn\r\n      }\r\n    );\r\n  if (controlOptions?.disabled) {\r\n    result.disable();\r\n  };\r\n  return result;\r\n}","/*\r\n * Public API Surface of ngx-extended-form-builder\r\n */\r\n\r\nexport * from './lib/ngx-extended-form-builder';","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":[],"mappings":"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"}