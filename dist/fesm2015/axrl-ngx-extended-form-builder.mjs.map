{"version":3,"file":"axrl-ngx-extended-form-builder.mjs","sources":["../../projects/ngx-extended-form-builder/src/lib/ngx-extended-form-builder.ts","../../projects/ngx-extended-form-builder/src/public-api.ts","../../projects/ngx-extended-form-builder/src/axrl-ngx-extended-form-builder.ts"],"sourcesContent":["import { FormGroup, FormArray, FormControl } from \"@angular/forms\";\nimport type { ValidatorFn, ValidationErrors, AsyncValidatorFn, AbstractControl, FormControlOptions } from \"@angular/forms\";\nimport { Observable } from \"rxjs\";\n\n/**\n * Вспомогательная утилита типа.\n * На вход принимает некий тип T, возвращает список только строковых ключей этого типа, при этом значения этих ключей не являются Observable.\n */\nexport type StringKeys<T> = {\n  [ K in keyof T ]: T[ K ] extends Observable<unknown> ?\n  never :\n  K extends string ?\n  K : never;\n}[ keyof T ];\n\n/**\n * Вспомогательный alias-тип ключей в объекте Map, содержащем конфигурацию валидаторов контролов.\n */\nexport type ControlsNames<T> = T extends Observable<unknown> ?\n  never :\n  T extends Array<infer U> ?\n  'main' | 'mainItems' | `mainItems.${ PropertyesKeys<U> }` :\n  'main' | PropertyesKeys<T>;\n/**\n * Вспомогательная утилита типа.\n * На вход принимает некий тип T, возвращает только строковые ключи этого типа.\n */\nexport type PropertyesKeys<T> = T extends undefined | null | number | boolean | symbol | Observable<unknown> ?\n  never :\n  T extends string ?\n  T :\n  T extends Array<infer U> ?\n  PropertyesKeys<U> :\n  {\n    [ K in keyof T ]-?: K extends string ?\n    T[ K ] extends (string | number | boolean | symbol | undefined | null) ?\n    K :\n    T[ K ] extends Observable<unknown> ?\n    never :\n    T[ K ] extends Array<infer U> ?\n    `${ K }Items.${ PropertyesKeys<U> }` | `${ K }Items` | K :\n    `${ K }.${ PropertyesKeys<T[ K ]> }` | K : never\n  }[ keyof T ];\n/**\n * Упрощенная запись для типа объекта FormGroup, образованного из типа T.\n */\nexport type FormGroupType<T> = FormGroup<{ [ K in StringKeys<T> ]: ScanFormType<T[ K ]>; }>;\n\n/**\n * Универсальный тип-утилита.\n * Для любого типа Т выводит правильный тип создаваемой формы, включая любой уровень вложенности.\n * ВАЖНО!\n * Чтобы избежать ошибки переполнения стэка вызовов в рекурсивном процессе создания формы, для любых\n * Observable-значений ( в т.ч., к примеру, Subject  * и EventEmitter) соответствующий элемент формы не создается.\n * ScanFormType это также учитывает.\n */\nexport type ScanFormType<T> = T extends AbstractControl<unknown, unknown> ?\n  T :\n  T extends null | undefined ?\n  never :\n  T extends Array<infer U> ?\n  FormArray<ScanFormType<U>> :\n  T extends (string | number | boolean | symbol | null | undefined) ?\n  FormControl<T> :\n  FormGroupType<T>;\n\ntype MakeControlOptions = Omit<FormControlOptions, 'validators' | 'asyncValidators'> & {\n  disabled?: boolean;\n  validators?: ValidatorFn[];\n  asyncValidators?: AsyncValidatorFn[];\n};\n\nfunction getValidatorsOrNull<T>(\n  key: ControlsNames<T>,\n  options?: Map<ControlsNames<T>, MakeControlOptions>,\n  addLift: boolean = false\n): MakeControlOptions | null | undefined {\n  const result = options && options.has(key) ? options.get(key) : null;\n  if (addLift) {\n    if (result && result.validators) {\n      result.validators.push(<ValidatorFn> liftErrors);\n      return result;\n    } else {\n      if (result) {\n        result.validators = [ liftErrors ];\n        return result;\n      } else {\n        return {\n          validators: [ liftErrors ]\n        };\n      };\n    }\n  } else {\n    return result;\n  };\n}\n\nfunction makeNewMainMap<I, O>(\n  key: ControlsNames<I>,\n  oldMap?: Map<ControlsNames<I>, MakeControlOptions>,\n): Map<ControlsNames<O>, MakeControlOptions> | undefined {\n  if (!oldMap || key === 'main') {\n    return <Map<ControlsNames<O>, MakeControlOptions> | undefined> oldMap;\n  } else {\n    if (!oldMap.has(key) && !oldMap.has(<ControlsNames<I>> `${ key }Items`)) {\n      return new Map<ControlsNames<O>, MakeControlOptions>(\n        Array.from(\n          oldMap.entries()\n        ).filter(\n          item => item[ 0 ] !== 'main' && item[ 0 ] !== 'mainItems'\n        ).map(\n          ([ entryKey, entryValue ]) => [ <ControlsNames<O>>(entryKey.startsWith(`${ key }.`) ? entryKey.replace(`${ key }.`, '') : entryKey), entryValue ]\n        )\n      );\n    } else {\n      const filterPredicate = oldMap.has(<ControlsNames<I>> 'main') ?\n        oldMap.has(<ControlsNames<I>> 'mainItems') ?\n          (item: [ ControlsNames<I>, MakeControlOptions ]) => {\n            const pre = item[ 0 ] !== (key + 'Items');\n            return item[ 0 ] !== key && pre && item[ 0 ] !== 'main' && item[ 0 ] !== 'mainItems';\n          } :\n          (item: [ ControlsNames<I>, MakeControlOptions ]) => {\n            const pre = item[ 0 ] !== (key + 'Items');\n            return item[ 0 ] !== key && key[ 0 ] !== (key + 'Items') && item[ 0 ] !== 'main';\n          } :\n        oldMap.has(<ControlsNames<I>> 'mainItems') ?\n          (item: [ ControlsNames<I>, MakeControlOptions ]) => {\n            const pre = item[ 0 ] !== (key + 'Items');\n            return item[ 0 ] !== key && pre && item[ 0 ] !== 'mainItems';\n          } :\n          (item: [ ControlsNames<I>, MakeControlOptions ]) => {\n            const pre = item[ 0 ] !== (key + 'Items');\n            return item[ 0 ] !== key && pre;\n          };\n      const newMainValidatorsArray: [ ControlsNames<O>, MakeControlOptions ][] = oldMap.has(key) ?\n        oldMap.has(<ControlsNames<I>> `${ key }Items`) ?\n          [\n            [ <ControlsNames<O>> 'main', oldMap.get(key)! ],\n            [ <ControlsNames<O>> 'mainItems', oldMap.get(<ControlsNames<I>> `${ key }Items`)! ]\n          ] :\n          [\n            [ <ControlsNames<O>> 'main', oldMap.get(key)! ],\n          ] :\n        oldMap.has(<ControlsNames<I>> `${ key }Items`) ?\n          [\n            [ <ControlsNames<O>> 'mainItems', oldMap.get(<ControlsNames<I>> `${ key }Items`)! ]\n          ] :\n          [];\n      const filtered = Array.from(\n        oldMap.entries()\n      ).filter(filterPredicate);\n      const result = new Map<ControlsNames<O>, MakeControlOptions>([\n        ...newMainValidatorsArray,\n        ...filtered.map<[ ControlsNames<O>, MakeControlOptions ]>(\n          ([ entryKey, entryValue ]) => [ <ControlsNames<O>>(\n            entryKey.startsWith(`${ key }.`) ?\n              entryKey.replace(`${ key }.`, '') :\n              entryKey.startsWith(`${ key }Items.`) ?\n                entryKey.replace(`${ key }Items.`, '') :\n                entryKey\n          ), entryValue ]\n        )\n      ]);\n      console.log(key, oldMap, filtered, result);\n      return result;\n    };\n  };\n}\n\n/**\n@function makeForm<T>\n  Фабричная функция для создания Angular Reactive Form.\nВ отличие от стандартного FormBuilder - а в пакете @angular/forms, при создании формы из сложных объектов,\nсохраняется вложенность контролов - каждый вложенный объект превращается во вложенную FormGroup,\n  обычные свойства объектов становятся FormControl - ами, а массивы - FormArray - ми.\nПри этом создаваемая форма имеет более строгую типизацию.\n\n  ВАЖНО!\n   Чтобы избежать ошибки переполнения стэка вызовов в рекурсивном процессе создания формы, для любых;\nObservable - значений(в т.ч., к примеру, Subject * и EventEmitter) соответствующий элемент формы не создается.\n * @param source  источник данных типа T для создания формы.\n * @param keysValidator объект Map с конфигурацией синхронных валидаторов контролов формы.\n * В качестве ключей могут быть указаны следующие значения:\n *  PropertyesKeys<T> - строковые ключи в типе T, включая строковые ключи всех вложенных типов, разделенные \".\" - точкой.\n    Например имеется такой тип:\n    ```ts\n                    interface User {\n                      firstname: string;\n                      lastname: string;\n                      phone:  {\n                        code: string;\n                        number: string;\n                        }\n                      };\n    ```\n    Для формы, которая будет создана из объекта User в конфигурации валидаторов названия контролов можно будет указать так:\n    `lastname` или`phone`, или`phone.code`.\n\n   'main' - специальное значение, являющееся признаком того, что массив валидаторов необходимо\n    назначить самому объекту формы, а не вложеным контролам.\n\n   'mainItems' - используется только если source является массивом. Специальное значение, являющееся признаком того,\n  что массив валидаторов необходимо назначить для всех элементов массива FormArray.\n * @param asyncKeysValidator объект Map, аналогичный keysValidator, но для асинхронных валидаторов\n * @returns объект типизированной формы - FormGroup, FormArray или FormControl в зависимости от типа значения source.\n */\nexport function makeForm<T extends unknown>(\n  source: T,\n  options?: Map<ControlsNames<T>, MakeControlOptions>,\n): ScanFormType<T> {\n  const form = !!source && (typeof source === 'object' || typeof source === 'function') ?\n    source instanceof Array<unknown> ?\n      makeArray(source, options) :\n      makeGroup(<object> source, 'main', options) :\n    makeControl(<undefined | null | number | boolean | symbol | string> source, options);\n  return <ScanFormType<T>> form;\n};\n\nfunction liftErrors(control: AbstractControl): ValidationErrors | null {\n  if (control instanceof FormControl) {\n    return null;\n  } else {\n    const allControls = control instanceof FormGroup ?\n      Object.values(control.controls) :\n      control instanceof FormArray ?\n        control.controls :\n        [];\n    const invalidControls = allControls.filter(control => control.status === 'INVALID');\n    return invalidControls.length === 0 ? null : invalidControls.reduce(\n      (accumulator, current) => {\n        if (current.errors) {\n          addValidationErrors(current.errors, accumulator);\n        };\n        return accumulator;\n      }, <ValidationErrors> {}\n    );\n  }\n}\n\nexport function liftValidationErrors(control: AbstractControl): ValidationErrors | null {\n  const allControls = control instanceof FormGroup ?\n    Object.values(control.controls) :\n    control instanceof FormArray ?\n      control.controls :\n      [];\n  const invalidControls = allControls.filter(control => control.status === 'INVALID');\n  const errors: ValidationErrors = invalidControls.length === 0 ? {} : invalidControls.reduce(\n    (accumulator, current) => {\n      if (current.errors) {\n        addValidationErrors(current.errors, accumulator);\n      };\n      const innerErrors = liftValidationErrors(current);\n      if (innerErrors) {\n        addValidationErrors(innerErrors, accumulator);\n      };\n      return accumulator;\n    }, <ValidationErrors> {}\n  );\n  return Object.values(errors).length === 0 ? null : errors;\n};\n\nfunction addValidationErrors(additionErrors: ValidationErrors, currentErrors: ValidationErrors) {\n  Object.entries(additionErrors).forEach(\n    entry => currentErrors[ entry[ 0 ] ] = entry[ 1 ]\n  );\n}\n\nfunction makeControl<T extends undefined | null | number | boolean | symbol | string>(\n  source: T | FormControl<T | null>,\n  options?: Map<ControlsNames<T>, MakeControlOptions>\n): FormControl<T | null> {\n  const controlOptions = getValidatorsOrNull(<ControlsNames<T>> 'main', options, false);\n  const result = source instanceof FormControl ?\n    source :\n    new FormControl<T | null>(\n      !!source && typeof source == 'string' && (source.includes('0001-01-01') || source.includes('1970-01-01')) ? null : source\n      ,\n      {\n        validators: controlOptions?.validators,\n        asyncValidators: controlOptions?.asyncValidators,\n        updateOn: controlOptions?.updateOn,\n        nonNullable: controlOptions?.nonNullable\n      },\n    );\n  if (controlOptions?.disabled) {\n    result.disable();\n  };\n  return result;\n}\n\nfunction makeGroup<T extends object = object>(\n  source: T | FormGroupType<T>,\n  internalKey: ControlsNames<T>,\n  options?: Map<ControlsNames<T>, MakeControlOptions>\n): FormGroupType<T> {\n  const controlOptions = getValidatorsOrNull(internalKey, options, false);\n  const result = source instanceof FormGroup<{ [ K in StringKeys<T> ]: ScanFormType<T[ K ]>; }> ?\n    source :\n    (<[ StringKeys<T>, T[ StringKeys<T> ] ][]> Object.entries(source)).reduce(\n      (accumulator: FormGroup, entry: [ StringKeys<T>, T[ StringKeys<T> ] ]) => {\n        const key = entry[ 0 ];\n        const value = entry[ 1 ];\n        if (!(value instanceof Observable)) {\n          accumulator.addControl(\n            key,\n            !!value && (\n              value instanceof FormGroup || value instanceof FormArray || value instanceof FormControl\n            ) ?\n              <ScanFormType<T[ StringKeys<T> ]>> value :\n              makeForm<T[ StringKeys<T> ]>(\n                value,\n                makeNewMainMap<T, T[ StringKeys<T> ]>(<ControlsNames<T>> key, options),\n              )\n          );\n        };\n        return <FormGroupType<T>> accumulator;\n      }, new FormGroup<{ [ K in StringKeys<T> ]: ScanFormType<T[ K ]>; }>(<{ [ K in StringKeys<T> ]: ScanFormType<T[ K ]>; }> {},\n        {\n          validators: controlOptions?.validators,\n          asyncValidators: controlOptions?.asyncValidators,\n          updateOn: controlOptions?.updateOn,\n        },\n      )\n    );\n  if (controlOptions?.disabled) {\n    result.disable();\n  };\n  return result;\n}\n\nfunction makeArray<T extends Array<unknown>, E = T extends Array<infer U> ? U : never>(\n  source: E[] | FormArray<ScanFormType<E>>,\n  options?: Map<ControlsNames<T>, MakeControlOptions>\n): FormArray<ScanFormType<E>> {\n  const controlOptions = getValidatorsOrNull(<ControlsNames<T>> 'main', options, false);\n  const result = source instanceof FormArray ?\n    source :\n    new FormArray(\n      source.map(\n        (item: E) => {\n          const itemForm = makeForm(\n            item,\n            makeNewMainMap<T, E>(<ControlsNames<T>> 'mainItems', options),\n          );\n          return itemForm;\n        }),\n      {\n        validators: controlOptions?.validators,\n        asyncValidators: controlOptions?.asyncValidators,\n        updateOn: controlOptions?.updateOn\n      }\n    );\n  if (controlOptions?.disabled) {\n    result.disable();\n  };\n  return result;\n}","/*\n * Public API Surface of ngx-extended-form-builder\n */\n\nexport * from './lib/ngx-extended-form-builder';","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":[],"mappings":"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"}